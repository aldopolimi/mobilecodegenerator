«REM»
Copyright 2013 Gregorio Perego, Stefania Pezzetti
This file is part of it.polimi.mobilecodegenerator.

it.polimi.mobilecodegenerator is free software: 
you can redistribute it and/or modify it under the terms of the 
GNU General Public License as published by the Free Software Foundation, 
either version 3 of the License, or (at your option) any later version.

it.polimi.mobilecodegenerator is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
See the GNU General Public License for more details.You should have received a copy of the GNU General Public License
along with it.polimi.mobilecodegenerator. If not, see <http://www.gnu.org/licenses/>
«ENDREM»

«IMPORT metamodel»

«DEFINE propertiesDeclarations FOR ViewController-»
«IF audioRecorder!=null-»
@property (strong, nonatomic) IBOutlet UIButton *recordButton;
@property (strong, nonatomic) AVAudioRecorder *audioRecorder;
@property (strong, nonatomic) NSURL *recordedAudioUrl;
«ENDIF-»
«FOREACH audioPlayers AS ap-»
var «ap.id» = AVAudioPlayer()
«ENDFOREACH-»
«ENDDEFINE-»

«DEFINE viewDidAppear FOR ViewController-»
	«FOREACH audioPlayers AS ap-»
	«IF !ap.sourceType.toString().matches("hardwareFile")-»
	«IF ap.sourceType.toString().matches("localFile")-»
	«IF !ap.fileUri.matches("")-»
	let «ap.id»FilePathString = NSBundle.mainBundle().pathForResource("«ap.fileUri»", ofType: "mp3")
    if let myFilePathString = «ap.id»FilePathString {
        let myFilePathURL = NSURL(fileURLWithPath: myFilePathString)
        do {
            try «ap.id» = AVAudioPlayer(contentsOfURL: myFilePathURL)
        } catch {
          print("Audioplayer error.")
        }
        
    } else {
        print("File not found.")
    }
	«ELSE-»
	//TODO decomment the next lines and insert file NAME and EXTENSION
	/*
	let «ap.id»FilePathString = NSBundle.mainBundle().pathForResource("NAME", ofType: "EXTENSION")
    if let myFilePathString = «ap.id»FilePathString {
        let myFilePathURL = NSURL(fileURLWithPath: myFilePathString)
        do {
            try «ap.id» = AVAudioPlayer(contentsOfURL: myFilePathURL)
        } catch {
          print("Audioplayer error.")
        }
        
    } else {
        print("File not found.")
    }
    */
	«ENDIF-»
	«ELSEIF ap.sourceType.toString().matches("remoteFile")-»
	«IF !ap.fileUri.matches("")-»
	if let url = NSURL(string: "«ap.fileUri»") {
        getDataFromUrl(url) { (data, response, error)  in
            dispatch_async(dispatch_get_main_queue()) { () -> Void in
                guard let data = data where error == nil else {
                    print("Data error.")
                    return
                }
                do {
                    try self.«ap.id» = AVAudioPlayer(data: data)
                } catch {
                    print("Audioplayer error.")
                }
            }
        }
    } else {
        print("File not found.")
    }
	«ELSE-»
	//TODO decomment the next lines and insert the URI
	/*
	if let url = NSURL(string: "URI") {
        getDataFromUrl(url) { (data, response, error)  in
            dispatch_async(dispatch_get_main_queue()) { () -> Void in
                guard let data = data where error == nil else {
                    print("Data error.")
                    return
                }
                do {
                    try self.«ap.id» = AVAudioPlayer(data: data)
                } catch {
                    print("Audioplayer error.")
                }
            }
        }
    } else {
        print("File not found.")
    }
    */
	«ENDIF-»
	«ENDIF-»
	«ENDIF-»
	«ENDFOREACH-»
	
	«IF audioRecorder!=null-»
	//Create audios folder
    let documentsPath = NSURL(fileURLWithPath: NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0])
    let audiosPath = documentsPath.URLByAppendingPathComponent("audios")
    do {
        try NSFileManager.defaultManager().createDirectoryAtPath(audiosPath.path!, withIntermediateDirectories: true, attributes: nil)
    } catch let error as NSError {
        NSLog("Unable to create directory \(error.debugDescription)")
    }
    //Create audio file url
    let formatter = NSDateFormatter()
    formatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
    self.recordedAudioString = formatter.stringFromDate(NSDate()).stringByAppendingString(".caf")
    let url = NSURL(string: self.recordedAudioString)
    
    let audioSession = AVAudioSession.sharedInstance()
    do {
        try audioSession.setCategory(AVAudioSessionCategoryPlayAndRecord)
        try self.«audioRecorder.id» = AVAudioRecorder(URL: url!,
                                                 settings: recordSettings)
        self.«audioRecorder.id».prepareToRecord()
        self.recordButton.setTitle("Rec", forState: UIControlState.Normal)
    } catch {
    }	
	«ENDIF-»
«ENDDEFINE-»

«DEFINE audio FOR ViewController-»
//Function to get the data from a url
func getDataFromUrl(url:NSURL, completion: ((data: NSData?, response: NSURLResponse?, error: NSError? ) -> Void)) {
    NSURLSession.sharedSession().dataTaskWithURL(url) { (data, response, error) in
        completion(data: data, response: response, error: error)
        }.resume()
}

«FOREACH audioPlayers AS ap-»
@IBAction func «ap.id»Play(sender: UIButton) {

	«IF !ap.sourceType.toString().matches("hardwareFile")-»
    self.«ap.id».play()
    «ELSEIF audioRecorder!=null && !audioRecorder.audioPlayerId.matches("")-»
    if self.«audioRecorder.id».recording {
        self.«audioRecorder.id».stop()
        self.recordButton.setTitle("Rec", forState: UIControlState.Normal)
        if let url = NSURL(string: self.recordedAudioString) {
            getDataFromUrl(url) { (data, response, error)  in
                dispatch_async(dispatch_get_main_queue()) { () -> Void in
                    guard let data = data where error == nil else {
                        print("Data error.")
                        return
                    }
                    do {
                        try self.«audioRecorder.audioPlayerId» = AVAudioPlayer(data: data)
                    } catch {
                        print("Audioplayer error.")
                    }
                }
            }
        } else {
            print("File not found.")
        }
    }
    self.«audioRecorder.audioPlayerId».play()
    «ENDIF-»
}

@IBAction func «ap.id»Pause(sender: UIButton) {

	«IF !ap.sourceType.toString().matches("hardwareFile")-»
    self.«ap.id».pause()
    «ELSEIF audioRecorder!=null && !audioRecorder.audioPlayerId.matches("")-»
    self.«audioRecorder.audioPlayerId».pause()
    «ENDIF-»
}

@IBAction func «ap.id»Stop(sender: UIButton) {

	«IF !ap.sourceType.toString().matches("hardwareFile")-»
    self.«ap.id».pause()
    self.«ap.id».currentTime = 0
    «ELSEIF audioRecorder!=null && !audioRecorder.audioPlayerId.matches("")-»
    self.«audioRecorder.audioPlayerId».pause()
    self.«audioRecorder.audioPlayerId».currentTime = 0
    «ENDIF-»
}
«ENDFOREACH-»

«IF audioRecorder!=null-»
- (IBAction)record:(UIButton *)sender
{
    if (!self.audioRecorder.recording){ //start recording
    	«IF !audioRecorder.audioPlayerId.matches("")-»
    	[self.«audioRecorder.audioPlayerId» pause];
        [self.«audioRecorder.audioPlayerId» setCurrentTime:0];
        «ENDIF-»
        
    	NSString* audiosPath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0] stringByAppendingString:@"/audios"];
        [[NSFileManager defaultManager] createDirectoryAtPath:audiosPath withIntermediateDirectories:YES attributes:nil error:nil];
        NSDateFormatter *formatter=[[NSDateFormatter alloc]init];
        [formatter setDateFormat:@"yyyy-MM-dd_HH-mm-ss"] ;
        NSString* filename = [[formatter stringFromDate:[NSDate date]] stringByAppendingString:@".caf"];
        self.recordedAudioUrl = [NSURL fileURLWithPath:[audiosPath stringByAppendingPathComponent:filename]];
    	
        AVAudioSession *audioSession = [AVAudioSession sharedInstance];
        [audioSession setCategory :AVAudioSessionCategoryPlayAndRecord error:nil];
        [audioSession setActive:YES error:nil];
        NSDictionary *recordSettings = [NSDictionary dictionaryWithObjectsAndKeys:
                                        [NSNumber numberWithInt:AVAudioQualityMin],AVEncoderAudioQualityKey,
                                        [NSNumber numberWithInt:16],AVEncoderBitRateKey,
                                        [NSNumber numberWithInt: 2],AVNumberOfChannelsKey,
                                        [NSNumber numberWithFloat:44100.0],AVSampleRateKey,nil];
        NSError *error = nil;
        self.audioRecorder = [[AVAudioRecorder alloc] initWithURL:self.recordedAudioUrl settings:recordSettings error:&error];
        [self.audioRecorder prepareToRecord];
        [self.audioRecorder record];
        [self.recordButton setTitle:@"Stop" forState:UIControlStateNormal];
    }
    else{  //stop recording
        [self.audioRecorder stop];
        [self.recordButton setTitle:@"Rec" forState:UIControlStateNormal];
        «IF !audioRecorder.audioPlayerId.matches("")-»
		NSError *error = nil;
		self.«audioRecorder.audioPlayerId» = [[AVAudioPlayer alloc] initWithContentsOfURL:self.recordedAudioUrl error:&error];
		if(error){
		    //TODO handle the audio player initialization error
		}
		«ENDIF-»
    }
}
«ENDIF-»
«ENDDEFINE-»

«DEFINE viewDidDisappear FOR ViewController-»
	«IF audioRecorder!=null-»
	if(self.audioRecorder!=nil && self.audioRecorder.isRecording){
	    [self.audioRecorder stop];
	    [self.recordButton setTitle:@"Rec" forState:UIControlStateNormal];
	}
	«IF !audioRecorder.audioPlayerId.matches("")-»
	if(self.«audioRecorder.audioPlayerId»!=nil && self.«audioRecorder.audioPlayerId».isPlaying){
	    [self.«audioRecorder.audioPlayerId» pause];
	    [self.«audioRecorder.audioPlayerId» setCurrentTime:0];
	}
	«ENDIF-»
	«ENDIF-»
	«FOREACH audioPlayers AS ap-»
	«IF ap!=null && !ap.sourceType.toString().matches("hardwareFile")-»
	if self.«ap.id»!=nil && self.«ap.id».playing {
	    self.«ap.id».pause()
	    self.«ap.id».currentTime = 0
	}
	«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE-»