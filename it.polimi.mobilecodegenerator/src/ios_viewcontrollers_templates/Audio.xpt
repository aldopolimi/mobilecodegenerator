«REM»
Copyright 2016 Gregorio Perego, Stefania Pezzetti, Aldo Pintus
This file is part of it.polimi.mobilecodegenerator.

it.polimi.mobilecodegenerator is free software: 
you can redistribute it and/or modify it under the terms of the 
GNU General Public License as published by the Free Software Foundation, 
either version 3 of the License, or (at your option) any later version.

it.polimi.mobilecodegenerator is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
See the GNU General Public License for more details.You should have received a copy of the GNU General Public License
along with it.polimi.mobilecodegenerator. If not, see <http://www.gnu.org/licenses/>
«ENDREM»

«IMPORT metamodel»

«DEFINE propertiesDeclarations FOR ViewController-»
«IF audioRecorder!=null-»
@IBOutlet weak var recordButton: UIButton!
var audioRecorder: AVAudioRecorder!
var audiosUrl: NSURL!
var recordedAudioUrl: NSURL!
let recordSettings = [
	AVSampleRateKey : NSNumber(float: Float(44100.0)),
	AVFormatIDKey : NSNumber(int: Int32(kAudioFormatMPEG4AAC)),
	AVNumberOfChannelsKey : NSNumber(int: 1),
	AVEncoderAudioQualityKey : NSNumber(int: Int32(AVAudioQuality.Medium.rawValue))
]
«ENDIF-»
«FOREACH audioPlayers AS ap-»
var «ap.id»: AVAudioPlayer!
«ENDFOREACH-»
«ENDDEFINE-»

«DEFINE viewDidAppear FOR ViewController-»
	«FOREACH audioPlayers AS ap-»
	«IF !ap.sourceType.toString().matches("hardwareFile")-»
	«IF ap.sourceType.toString().matches("localFile")-»
	«IF !ap.fileUri.matches("")-»
	let «ap.id»FilePathString = NSBundle.mainBundle().pathForResource("«ap.fileUri»", ofType: "mp3")
	let «ap.id»FilePathUrl = NSURL(fileURLWithPath: «ap.id»FilePathString)
	do {
		try «ap.id» = AVAudioPlayer(contentsOfURL: «ap.id»FilePathUrl)
	} catch let error as NSError {
		NSLog("Unable to initialize AVAudioPlayer: \(error.debugDescription)")
	}  
		
	«ELSE-»
	//TODO decomment the next lines and insert file NAME and EXTENSION
	/*
	let «ap.id»FilePathString = NSBundle.mainBundle().pathForResource("NAME", ofType: "EXTENSION")
	let «ap.id»FilePathUrl = NSURL(fileURLWithPath: «ap.id»FilePathString)
	do {
		try «ap.id» = AVAudioPlayer(contentsOfURL: «ap.id»FilePathUrl)
	} catch let error as NSError {
		NSLog("Unable to initialize AVAudioPlayer: \(error.debugDescription)")
	}
    */
	«ENDIF-»
	«ELSEIF ap.sourceType.toString().matches("remoteFile")-»
	«IF !ap.fileUri.matches("")-»
	let let «ap.id»FileRemoteUrl = NSURL(string: "«ap.fileUri»") {
	getDataFromUrl(let «ap.id»FileRemoteUrl) { (data, response, error)  in
		dispatch_async(dispatch_get_main_queue()) { () -> Void in
			guard let data = data where error == nil else {
				NSLog("Data error")
				return
			}
			do {
				try self.«ap.id» = AVAudioPlayer(data: data)
			} catch let error as NSError {
				NSLog("Unable to initialize AVAudioPlayer: \(error.debugDescription)")
			}
		}
	}
	«ELSE-»
	//TODO decomment the next lines and insert the URI
	/*
	let let «ap.id»FileRemoteUrl = NSURL(string: "URI") {
	getDataFromUrl(let «ap.id»FileRemoteUrl) { (data, response, error)  in
		dispatch_async(dispatch_get_main_queue()) { () -> Void in
			guard let data = data where error == nil else {
				NSLog("Data error")
				return
			}
			do {
				try self.«ap.id» = AVAudioPlayer(data: data)
			} catch let error as NSError {
				NSLog("Unable to initialize AVAudioPlayer: \(error.debugDescription)")
			}
		}
	}
    */
	«ENDIF-»
	«ENDIF-»
	«ENDIF-»
	«ENDFOREACH-»
	
	«IF audioRecorder!=null-»
	//Create audios folder
	let documentsPath = NSURL(fileURLWithPath: NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0])
	self.audiosUrl = documentsPath.URLByAppendingPathComponent("audios")
	do {
		try NSFileManager.defaultManager().createDirectoryAtPath(audiosUrl.path!, withIntermediateDirectories: true, attributes: nil)
	} catch let error as NSError {
		NSLog("Unable to create directory: \(error.debugDescription)")
	}
	
	//Create audio file url
	let dateFormatter = NSDateFormatter()
	dateFormatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
	let fileNameString = dateFormatter.stringFromDate(NSDate()).stringByAppendingString(".caf")
	self.recordedAudioUrl = self.audiosUrl.URLByAppendingPathComponent(fileNameString)
	
	//Init audiorecorder
	do {
		try self.audioRecorder = AVAudioRecorder(URL: self.recordedAudioUrl, settings: self.recordSettings)
	} catch let error as NSError {
		NSLog("Unable to initialize AVAudioRecorder: \(error.debugDescription)")
	}
	«ENDIF-»
«ENDDEFINE-»

«DEFINE audio FOR ViewController-»
	«IF audioPlayers.size != 0-»
	//Function to get the data from a url
	func getDataFromUrl(url:NSURL, completion: ((data: NSData?, response: NSURLResponse?, error: NSError? ) -> Void)) {
	    NSURLSession.sharedSession().dataTaskWithURL(url) { (data, response, error) in
	        completion(data: data, response: response, error: error)
	        }.resume()
	}
	«ENDIF-»

«FOREACH audioPlayers AS ap-»
@IBAction func «ap.id»Play(sender: UIButton) {

	«IF !ap.sourceType.toString().matches("hardwareFile")-»
    self.«ap.id».play()
    «ELSEIF audioRecorder!=null && !audioRecorder.audioPlayerId.matches("")-»
    if !self.audioRecorder.recording && self.«audioRecorder.audioPlayerId» != nil {
		self.«audioRecorder.audioPlayerId».play()
	}
    «ENDIF-»
}

@IBAction func «ap.id»Pause(sender: UIButton) {

	«IF !ap.sourceType.toString().matches("hardwareFile")-»
    self.«ap.id».pause()
    «ELSEIF audioRecorder!=null && !audioRecorder.audioPlayerId.matches("")-»
    if !self.audioRecorder.recording && self.«audioRecorder.audioPlayerId» != nil {
		self.«audioRecorder.audioPlayerId».pause()
	}
    «ENDIF-»
}

@IBAction func «ap.id»Stop(sender: UIButton) {

	«IF !ap.sourceType.toString().matches("hardwareFile")-»
    self.«ap.id».pause()
    self.«ap.id».currentTime = 0
    «ELSEIF audioRecorder!=null && !audioRecorder.audioPlayerId.matches("")-»
    if !self.audioRecorder.recording && self.«audioRecorder.audioPlayerId» != nil {
		self.«audioRecorder.audioPlayerId».pause()
		self.«audioRecorder.audioPlayerId».currentTime = 0
	}
    «ENDIF-»
}
«ENDFOREACH-»

«IF audioRecorder!=null-»
@IBAction func record(sender: UIButton) {
	
	if !self.audioRecorder.recording {
		
		//Create a new audio file url
		let dateFormatter = NSDateFormatter()
		dateFormatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
		let fileNameString = dateFormatter.stringFromDate(NSDate()).stringByAppendingString(".caf")
		self.recordedAudioUrl = self.audiosUrl.URLByAppendingPathComponent(fileNameString)
		
		//Re-Init audiorecorder
		do {
			try self.audioRecorder = AVAudioRecorder(URL: self.recordedAudioUrl, settings: self.recordSettings)
		} catch let error as NSError {
			NSLog("Unable to initialize AVAudioRecorder: \(error.debugDescription)")
		}
		
		//Record button -> Stop
		self.recordButton.setTitle("Stop", forState: UIControlState.Normal)
		
		//Start recording
		let audioSession = AVAudioSession.sharedInstance()
		do {
			try audioSession.setCategory(AVAudioSessionCategoryPlayAndRecord)
			try audioSession.setActive(true)
			self.audioRecorder.prepareToRecord()
			self.audioRecorder.record()
		} catch let error as NSError {
			NSLog("Unable to initialize AVAudioSession: \(error.debugDescription)")
		}
		
	} else {
		
		//Record button -> Rec
		self.recordButton.setTitle("Rec", forState: UIControlState.Normal)
		
		//Stop recording
		let audioSession = AVAudioSession.sharedInstance()
		do {
			try audioSession.setActive(false)
			self.audioRecorder.stop()
		} catch let error as NSError {
			NSLog("Unable to deactivate AVAudioSession: \(error.debugDescription)")
		}
		
		//Init audioplayer
		getDataFromUrl(self.recordedAudioUrl) { (data, response, error)  in
			dispatch_async(dispatch_get_main_queue()) { () -> Void in
				guard let data = data where error == nil else {
					print("Data error")
					return
				}
				do {
					try self.«audioRecorder.audioPlayerId» = AVAudioPlayer(data: data)
				} catch let error as NSError {
					NSLog("Unable to initialize AVAudioPlayer: \(error.debugDescription)")
				}
			}
		}
		
	}
}
«ENDIF-»
«ENDDEFINE-»

«DEFINE viewDidDisappear FOR ViewController-»
	«IF audioRecorder!=null-»
	if self.audioRecorder != nil && self.audioRecorder.recording {
	    self.recordButton.setTitle("Rec", forState: UIControlState.Normal)
		self.audioRecorder.stop()
	}
	«IF !audioRecorder.audioPlayerId.matches("")-»
	if self.«audioRecorder.audioPlayerId» != nil && self.«audioRecorder.audioPlayerId».playing {
	    self.«audioRecorder.audioPlayerId».pause()
	    self.«audioRecorder.audioPlayerId».currentTime = 0
	}
	«ENDIF-»
	«ENDIF-»
	«FOREACH audioPlayers AS ap-»
	«IF ap!=null && !ap.sourceType.toString().matches("hardwareFile")-»
	if self.«ap.id» != nil && self.«ap.id».playing {
	    self.«ap.id».pause()
	    self.«ap.id».currentTime = 0
	}
	«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE-»